["  import torch\n", "  import math\n", "  import numpy as np\n", "  \n", "  def log10(x):\n", "-       \"\"\"Convert a new tensor with the base-10 logarithm of the elements of x. \"\"\"\n", "? --\n", "+     \"\"\"Convert a new tensor with the base-10 logarithm of the elements of x. \"\"\"\n", "-       return torch.log(x) / math.log(10)\n", "? --\n", "+     return torch.log(x) / math.log(10)\n", "  \n", "  class Result(object):\n", "      def __init__(self):\n", "          self.irmse, self.imae = 0, 0\n", "          self.mse, self.rmse, self.mae = 0, 0, 0\n", "          self.absrel, self.lg10 = 0, 0\n", "          self.delta1, self.delta2, self.delta3 = 0, 0, 0\n", "          self.data_time, self.gpu_time = 0, 0\n", "- \n", "+         self.loss = 0 \n", "      def set_to_worst(self):\n", "          self.irmse, self.imae = np.inf, np.inf\n", "          self.mse, self.rmse, self.mae = np.inf, np.inf, np.inf\n", "          self.absrel, self.lg10 = np.inf, np.inf\n", "          self.delta1, self.delta2, self.delta3 = 0, 0, 0\n", "          self.data_time, self.gpu_time = 0, 0\n", "- \n", "+         self.loss = np.inf\n", "-     def update(self, irmse, imae, mse, rmse, mae, absrel, lg10, delta1, delta2, delta3, gpu_time, data_time):\n", "+     def update(self, irmse, imae, mse, rmse, mae, absrel, lg10, delta1, delta2, delta3, gpu_time, data_time, loss):\n", "?                                                                                                            ++++++\n", "          self.irmse, self.imae = irmse, imae\n", "          self.mse, self.rmse, self.mae = mse, rmse, mae\n", "          self.absrel, self.lg10 = absrel, lg10\n", "          self.delta1, self.delta2, self.delta3 = delta1, delta2, delta3\n", "          self.data_time, self.gpu_time = data_time, gpu_time\n", "- \n", "+         self.loss = loss\n", "-     def evaluate(self, output, target):\n", "?                        ^^  ^^\n", "+     def evaluate(self, depth_pred, target, loss):\n", "?                        ^^^ ++ ^^^        ++++++\n", "+         valid_mask = target>0\n", "+         depth_pred = depth_pred[valid_mask]\n", "-         valid_mask = ((target>0) + (output>0)) > 0\n", "- \n", "-         output = 1e3 * output[valid_mask]\n", "-         target = 1e3 * target[valid_mask]\n", "?                 ------\n", "+         target = target[valid_mask]\n", "-         abs_diff = (output - target).abs()\n", "?                     ^^  ^^\n", "+         abs_diff = (depth_pred - target).abs()\n", "?                     ^^^ ++ ^^^\n", "  \n", "          self.mse = float((torch.pow(abs_diff, 2)).mean())\n", "          self.rmse = math.sqrt(self.mse)\n", "          self.mae = float(abs_diff.mean())\n", "-         self.lg10 = float((log10(output) - log10(target)).abs().mean())\n", "?                                  ^^  ^^\n", "+         self.lg10 = float((log10(depth_pred) - log10(target)).abs().mean())\n", "?                                  ^^^ ++ ^^^\n", "          self.absrel = float((abs_diff / target).mean())\n", "- \n", "-         maxRatio = torch.max(output / target, target / output)\n", "-         self.delta1 = float((maxRatio < 1.25).float().mean())\n", "-         self.delta2 = float((maxRatio < 1.25 ** 2).float().mean())\n", "-         self.delta3 = float((maxRatio < 1.25 ** 3).float().mean())\n", "+         # corrected way of calculating delta accuracy\n", "+         upper_bound_delta1 = (1.25)*target\n", "+         lower_bound_delta1 = (0.75)*target\n", "+         upper_bound_delta2 = (1.25**2)*target\n", "+         lower_bound_delta2 = (1-((1.25**2)-1))*target\n", "+         upper_bound_delta3 = (1.25**3)*target\n", "+         lower_bound_delta3 = (1-((1.25**3)-1))*target\n", "+         self.delta1 = torch.logical_and((depth_pred >= lower_bound_delta1),(depth_pred <= upper_bound_delta1)).float().mean()\n", "+         self.delta2 = torch.logical_and((depth_pred >= lower_bound_delta2),(depth_pred <= upper_bound_delta2)).float().mean()\n", "+         self.delta3 = torch.logical_and((depth_pred >= lower_bound_delta3),(depth_pred <= upper_bound_delta3)).float().mean()\n", "          self.data_time = 0\n", "          self.gpu_time = 0\n", "  \n", "-         inv_output = 1 / output\n", "+         inv_depth_pred = 1 / depth_pred\n", "          inv_target = 1 / target\n", "-         abs_inv_diff = (inv_output - inv_target).abs()\n", "?                             ^^  ^^\n", "+         abs_inv_diff = (inv_depth_pred - inv_target).abs()\n", "?                             ^^^ ++ ^^^\n", "          self.irmse = math.sqrt((torch.pow(abs_inv_diff, 2)).mean())\n", "          self.imae = float(abs_inv_diff.mean())\n", "+         self.loss = loss\n", "  \n", "  \n", "  class AverageMeter(object):\n", "      def __init__(self):\n", "          self.reset()\n", "  \n", "      def reset(self):\n", "          self.count = 0.0\n", "  \n", "          self.sum_irmse, self.sum_imae = 0, 0\n", "          self.sum_mse, self.sum_rmse, self.sum_mae = 0, 0, 0\n", "          self.sum_absrel, self.sum_lg10 = 0, 0\n", "          self.sum_delta1, self.sum_delta2, self.sum_delta3 = 0, 0, 0\n", "          self.sum_data_time, self.sum_gpu_time = 0, 0\n", "- \n", "+         self.sum_loss = 0\n", "      def update(self, result, gpu_time, data_time, n=1):\n", "          self.count += n\n", "- \n", "+         result.loss = result.loss.cuda(0) # move loss tensor to single specified GPU \n", "          self.sum_irmse += n*result.irmse\n", "          self.sum_imae += n*result.imae\n", "          self.sum_mse += n*result.mse\n", "          self.sum_rmse += n*result.rmse\n", "          self.sum_mae += n*result.mae\n", "          self.sum_absrel += n*result.absrel\n", "          self.sum_lg10 += n*result.lg10\n", "-         self.sum_delta1 += n*result.delta1\n", "+         self.sum_delta1 += n*result.delta1.item()\n", "?                                           +++++++\n", "-         self.sum_delta2 += n*result.delta2\n", "+         self.sum_delta2 += n*result.delta2.item()\n", "?                                           +++++++\n", "-         self.sum_delta3 += n*result.delta3\n", "+         self.sum_delta3 += n*result.delta3.item()\n", "?                                           +++++++\n", "          self.sum_data_time += n*data_time\n", "          self.sum_gpu_time += n*gpu_time\n", "- \n", "+         self.sum_loss += n*result.loss\n", "      def average(self):\n", "          avg = Result()\n", "          avg.update(\n", "              self.sum_irmse / self.count, self.sum_imae / self.count,\n", "              self.sum_mse / self.count, self.sum_rmse / self.count, self.sum_mae / self.count,\n", "              self.sum_absrel / self.count, self.sum_lg10 / self.count,\n", "              self.sum_delta1 / self.count, self.sum_delta2 / self.count, self.sum_delta3 / self.count,\n", "-             self.sum_gpu_time / self.count, self.sum_data_time / self.count)\n", "+             self.sum_gpu_time / self.count, self.sum_data_time / self.count, self.sum_loss / self.count)\n", "?                                                                            ++++++++++++++++++++++++++++\n", "-         return avg", "+         return avg\n", "?                   +\n"]